<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>QTetris: Référence de la classe SceneObject</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="QTetris.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">QTetris
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">Projet IN204</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Liste&#160;des&#160;classes</span></a></li>
      <li><a href="classes.html"><span>Index&#160;des&#160;classes</span></a></li>
      <li><a href="inherits.html"><span>Hiérarchie&#160;des&#160;classes</span></a></li>
      <li><a href="functions.html"><span>Membres&#160;de&#160;classe</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tout</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Fonctions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pro-attribs">Attributs protégés</a> &#124;
<a href="class_scene_object-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe SceneObject</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> class.  
 <a href="class_scene_object.html#details">Plus de détails...</a></p>

<p><code>#include &lt;<a class="el" href="_scene_object_8h_source.html">SceneObject.h</a>&gt;</code></p>
<div class="dynheader">
Graphe d'héritage de SceneObject:</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object__inherit__graph.png" border="0" usemap="#_scene_object_inherit__map" alt="Inheritance graph"/></div>
<map name="_scene_object_inherit__map" id="_scene_object_inherit__map">
<area shape="rect" id="node2" href="class_tetromino.html" title="La classe Tetromino est un objet qui peut etre lui aussi present dans la Scene. Il represente la piec..." alt="" coords="29,336,136,472"/></map>
</div>
<div class="dynheader">
Graphe de collaboration de SceneObject:</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object__coll__graph.png" border="0" usemap="#_scene_object_coll__map" alt="Collaboration graph"/></div>
<map name="_scene_object_coll__map" id="_scene_object_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:afd3c25c53a9d562e49f5d0d288052842"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd3c25c53a9d562e49f5d0d288052842"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SceneObject</b> (int x, int y)</td></tr>
<tr class="separator:afd3c25c53a9d562e49f5d0d288052842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c4b963db519ceb4c654b8616fbe03d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#ad1c4b963db519ceb4c654b8616fbe03d">operator==</a> (const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;Obj) const </td></tr>
<tr class="memdesc:ad1c4b963db519ceb4c654b8616fbe03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operateur de comparaison ==.  <a href="#ad1c4b963db519ceb4c654b8616fbe03d"></a><br/></td></tr>
<tr class="separator:ad1c4b963db519ceb4c654b8616fbe03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103908e9871f10796a6cd47c34607606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a103908e9871f10796a6cd47c34607606">operator&lt;</a> (const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;Obj) const </td></tr>
<tr class="memdesc:a103908e9871f10796a6cd47c34607606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operateur de comparaison &lt;.  <a href="#a103908e9871f10796a6cd47c34607606"></a><br/></td></tr>
<tr class="separator:a103908e9871f10796a6cd47c34607606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53a078eda49350d1178a67e7641aea2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#ac53a078eda49350d1178a67e7641aea2">hitsTheFloor</a> () const </td></tr>
<tr class="memdesc:ac53a078eda49350d1178a67e7641aea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">hitsTheFloor verifie si l'objet est arrive a la dernier ligne en bas. Typiquement, le <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> present sur la scene ne peut plus descendre plus bas quand cette methode retourne true.  <a href="#ac53a078eda49350d1178a67e7641aea2"></a><br/></td></tr>
<tr class="separator:ac53a078eda49350d1178a67e7641aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a364d539d87eb3962a15ff58c80ac2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a08a364d539d87eb3962a15ff58c80ac2">hitsTheFloor2</a> () const </td></tr>
<tr class="memdesc:a08a364d539d87eb3962a15ff58c80ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">hitsTheFloor2 verifie si l'objet est enfonce en bas de la scene.  <a href="#a08a364d539d87eb3962a15ff58c80ac2"></a><br/></td></tr>
<tr class="separator:a08a364d539d87eb3962a15ff58c80ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95696937a096e824e9362d56b4e42fa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a95696937a096e824e9362d56b4e42fa0">hitsTheCeil</a> () const </td></tr>
<tr class="memdesc:a95696937a096e824e9362d56b4e42fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">hitsTheCeil verifie si l'objet est enfonce en haut de la scene.  <a href="#a95696937a096e824e9362d56b4e42fa0"></a><br/></td></tr>
<tr class="separator:a95696937a096e824e9362d56b4e42fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c0ac4c0c404b812b3b8d91a490e8c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a47c0ac4c0c404b812b3b8d91a490e8c6">hitsTheWall</a> () const </td></tr>
<tr class="memdesc:a47c0ac4c0c404b812b3b8d91a490e8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">hitsTheWall  <a href="#a47c0ac4c0c404b812b3b8d91a490e8c6"></a><br/></td></tr>
<tr class="separator:a47c0ac4c0c404b812b3b8d91a490e8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ba5917dcf69fcabcd36c5edab576c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#ad5ba5917dcf69fcabcd36c5edab576c5">collide</a> (const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;Obj) const </td></tr>
<tr class="memdesc:ad5ba5917dcf69fcabcd36c5edab576c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">collide: verifie la collision entre deux <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a>, c'est a dire les deux possedent des parties qui occupent la meme zone spaciale(meme x et y) sur la scene.  <a href="#ad5ba5917dcf69fcabcd36c5edab576c5"></a><br/></td></tr>
<tr class="separator:ad5ba5917dcf69fcabcd36c5edab576c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4286d4f4699ef94dddebed6d149e2970"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a4286d4f4699ef94dddebed6d149e2970">isAdjascent</a> (const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;Obj) const </td></tr>
<tr class="memdesc:a4286d4f4699ef94dddebed6d149e2970"><td class="mdescLeft">&#160;</td><td class="mdescRight">isAdjascent verifie si les deux <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> sont adjascents, c'est a dire si l'un deux possede une partie qui est directement a droite de l'autre(ou a sa gauche...).  <a href="#a4286d4f4699ef94dddebed6d149e2970"></a><br/></td></tr>
<tr class="separator:a4286d4f4699ef94dddebed6d149e2970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b888761430b2a22627db6ed7313c79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a30b888761430b2a22627db6ed7313c79">isUnder</a> (const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;Obj) const </td></tr>
<tr class="memdesc:a30b888761430b2a22627db6ed7313c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">isUnder verifie si l'objet courant possede une partie qui est directement en dessus de Obj.  <a href="#a30b888761430b2a22627db6ed7313c79"></a><br/></td></tr>
<tr class="separator:a30b888761430b2a22627db6ed7313c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d13d801e32173b4b138f06564ceb6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a1d13d801e32173b4b138f06564ceb6f9">glue</a> (<a class="el" href="class_scene_object.html">SceneObject</a> Obj)</td></tr>
<tr class="memdesc:a1d13d801e32173b4b138f06564ceb6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">glue: comme le nom l'indique, cette fonction colle Obj a l'object courant. Rien n'interdit de coller deux <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a>, pourvu qu'ils soient disjoints, mais pour preserver la logique du jeu, il ne faut coller que les objets proches entre eux(qui peuvent former un bloc unique).  <a href="#a1d13d801e32173b4b138f06564ceb6f9"></a><br/></td></tr>
<tr class="separator:a1d13d801e32173b4b138f06564ceb6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84c13efa3bb490ca9443798710109c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_scene_object.html">SceneObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#aa84c13efa3bb490ca9443798710109c0">simple_fall</a> () const </td></tr>
<tr class="memdesc:aa84c13efa3bb490ca9443798710109c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple_fall: fait tomber l'objet courant d'une ligne  <a href="#aa84c13efa3bb490ca9443798710109c0"></a><br/></td></tr>
<tr class="separator:aa84c13efa3bb490ca9443798710109c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7edd70ee989d54226c884fdffb6529e"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::set<br class="typebreak"/>
&lt; <a class="el" href="class_scene_object.html">SceneObject</a> &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#ac7edd70ee989d54226c884fdffb6529e">deleteLine</a> (int l) const </td></tr>
<tr class="memdesc:ac7edd70ee989d54226c884fdffb6529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">deleteLine: verifie supprime la ligne l si celle-ci peut etre complete.  <a href="#ac7edd70ee989d54226c884fdffb6529e"></a><br/></td></tr>
<tr class="separator:ac7edd70ee989d54226c884fdffb6529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ed5025e4dd72be01c4c3d438d47cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene_object.html#a90ed5025e4dd72be01c4c3d438d47cbd">print</a> (char **map) const </td></tr>
<tr class="memdesc:a90ed5025e4dd72be01c4c3d438d47cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">print: affiche le contenu du <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> courant sur le tableau passe en parametre  <a href="#a90ed5025e4dd72be01c4c3d438d47cbd"></a><br/></td></tr>
<tr class="separator:a90ed5025e4dd72be01c4c3d438d47cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Attributs protégés</h2></td></tr>
<tr class="memitem:a75b7a9ca6d227b6fab7a59a5bf062607"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75b7a9ca6d227b6fab7a59a5bf062607"></a>
std::set&lt; Points &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scene_basic_objects</b></td></tr>
<tr class="separator:a75b7a9ca6d227b6fab7a59a5bf062607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>The <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> class. </p>

<p>Définition à la ligne <a class="el" href="_scene_object_8h_source.html#l00057">57</a> du fichier <a class="el" href="_scene_object_8h_source.html">SceneObject.h</a>.</p>
</div><h2 class="groupheader">Documentation des fonctions membres</h2>
<a class="anchor" id="ad5ba5917dcf69fcabcd36c5edab576c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::collide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>collide: verifie la collision entre deux <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a>, c'est a dire les deux possedent des parties qui occupent la meme zone spaciale(meme x et y) sur la scene. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj,:</td><td>l'autre <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> a comparer avec le SceneObjet courant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>true s'il y a collision. </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00145">145</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_ad5ba5917dcf69fcabcd36c5edab576c5_icgraph.png" border="0" usemap="#class_scene_object_ad5ba5917dcf69fcabcd36c5edab576c5_icgraph" alt=""/></div>
<map name="class_scene_object_ad5ba5917dcf69fcabcd36c5edab576c5_icgraph" id="class_scene_object_ad5ba5917dcf69fcabcd36c5edab576c5_icgraph">
<area shape="rect" id="node2" href="class_scene.html#a5fecb70ddb90dcde0eb0bc66875b88ed" title="doPhysics: gere la physique (gravite+ suppressions de lignes multiples...etc)" alt="" coords="199,31,327,57"/><area shape="rect" id="node6" href="class_scene.html#ac5739680655eda8de8eb5f7dc80562fd" title="Scene::timerEvent" alt="" coords="199,81,327,108"/><area shape="rect" id="node7" href="class_scene.html#a53ff5a09e1c2b039706023677708951c" title="makeMove: fait bouger le tetromino courant suivant la commande utilisateur (a droite, a gauche ou vers le bas). L&#39;action ne sera pas effectuee si elle n&#39;est pas valide." alt="" coords="198,132,327,159"/><area shape="rect" id="node3" href="classgame_manager.html#a029638f6842dc0372ed41df0f6cc7c9c" title="mainloop : gerer les fontions ci&#45;dessous 1) verifier si on a besoin un nouveau tetrimino par la valeu..." alt="" coords="392,31,560,57"/><area shape="rect" id="node4" href="classgame_manager.html#a02a1a2ce80a6c1261744544229abb5d5" title="timerEvent va gerer les &quot;timer event&quot;" alt="" coords="624,5,797,32"/><area shape="rect" id="node5" href="class_main_window.html#a5edcbc314e782645cdf4db101eeb247d" title="quand le jeu viens de commencer, la fonction start va initiliser l&#39;affichage de niveau et de note Il ..." alt="" coords="645,56,776,83"/><area shape="rect" id="node8" href="classgame_manager.html#a0f980e9de05bc58ac618eb2f10b6232d" title="gestion des controles de clavier" alt="" coords="377,132,575,159"/><area shape="rect" id="node9" href="classwidget.html#a9bd43921188521397bfd559e878fe0af" title="quand le timer et gameManager marche, keyPressEvent() va passer les evenements au GameManager sinon i..." alt="" coords="633,132,788,159"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac7edd70ee989d54226c884fdffb6529e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::set&lt; <a class="el" href="class_scene_object.html">SceneObject</a> &gt;, bool &gt; SceneObject::deleteLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deleteLine: verifie supprime la ligne l si celle-ci peut etre complete. </p>
<p>Apres suppression, on obtient des fragments connexes qui composent l'objet courant apres suppression de la ligne.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">l,:</td><td>la ligne a supprimer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>les fragments connexes de l'objet courant apress suppression+ un boolean qui est egale a true s'il y a eu suppression </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00232">232</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d13d801e32173b4b138f06564ceb6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SceneObject::glue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_scene_object.html">SceneObject</a>&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>glue: comme le nom l'indique, cette fonction colle Obj a l'object courant. Rien n'interdit de coller deux <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a>, pourvu qu'ils soient disjoints, mais pour preserver la logique du jeu, il ne faut coller que les objets proches entre eux(qui peuvent former un bloc unique). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj,:</td><td>le SceneObjet a coller avec l'object courant </td></tr>
  </table>
  </dd>
</dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00208">208</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_a1d13d801e32173b4b138f06564ceb6f9_icgraph.png" border="0" usemap="#class_scene_object_a1d13d801e32173b4b138f06564ceb6f9_icgraph" alt=""/></div>
<map name="class_scene_object_a1d13d801e32173b4b138f06564ceb6f9_icgraph" id="class_scene_object_a1d13d801e32173b4b138f06564ceb6f9_icgraph">
<area shape="rect" id="node2" href="class_scene.html#a2c73e7f065e5df1726b170a6ca0cb794" title="simplify: regroupe les SceneObjects adjascents entre eux pour reduire le nombre d&#39;objets separes pres..." alt="" coords="185,81,295,108"/><area shape="rect" id="node3" href="class_scene.html#a09fef31f4f25e5c1ab2a1b4366710c05" title="gravity: fait tomber tout les objets(tout le monde tombe a la meme vitesse) et les relie entre eux (a..." alt="" coords="359,56,463,83"/><area shape="rect" id="node9" href="class_scene.html#a181b7a8684fe5dabe9d85c70a2b61497" title="deleteLines: suppression des lignes completes; modifie le score" alt="" coords="344,107,477,133"/><area shape="rect" id="node4" href="class_scene.html#a5fecb70ddb90dcde0eb0bc66875b88ed" title="doPhysics: gere la physique (gravite+ suppressions de lignes multiples...etc)" alt="" coords="525,5,653,32"/><area shape="rect" id="node8" href="class_scene.html#ac5739680655eda8de8eb5f7dc80562fd" title="Scene::timerEvent" alt="" coords="525,56,653,83"/><area shape="rect" id="node5" href="classgame_manager.html#a029638f6842dc0372ed41df0f6cc7c9c" title="mainloop : gerer les fontions ci&#45;dessous 1) verifier si on a besoin un nouveau tetrimino par la valeu..." alt="" coords="701,56,869,83"/><area shape="rect" id="node6" href="classgame_manager.html#a02a1a2ce80a6c1261744544229abb5d5" title="timerEvent va gerer les &quot;timer event&quot;" alt="" coords="917,31,1091,57"/><area shape="rect" id="node7" href="class_main_window.html#a5edcbc314e782645cdf4db101eeb247d" title="quand le jeu viens de commencer, la fonction start va initiliser l&#39;affichage de niveau et de note Il ..." alt="" coords="939,81,1069,108"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a95696937a096e824e9362d56b4e42fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::hitsTheCeil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hitsTheCeil verifie si l'objet est enfonce en haut de la scene. </p>
<dl class="section return"><dt>Renvoie</dt><dd>true si une partie de l'<a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> courant depasse le haut de la scene </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00122">122</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_a95696937a096e824e9362d56b4e42fa0_icgraph.png" border="0" usemap="#class_scene_object_a95696937a096e824e9362d56b4e42fa0_icgraph" alt=""/></div>
<map name="class_scene_object_a95696937a096e824e9362d56b4e42fa0_icgraph" id="class_scene_object_a95696937a096e824e9362d56b4e42fa0_icgraph">
<area shape="rect" id="node2" href="class_scene.html#ac5739680655eda8de8eb5f7dc80562fd" title="Scene::timerEvent" alt="" coords="224,5,352,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac53a078eda49350d1178a67e7641aea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::hitsTheFloor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hitsTheFloor verifie si l'objet est arrive a la dernier ligne en bas. Typiquement, le <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> present sur la scene ne peut plus descendre plus bas quand cette methode retourne true. </p>
<dl class="section return"><dt>Renvoie</dt><dd>true si l'objet atteint la derniere ligne du bas </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00100">100</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08a364d539d87eb3962a15ff58c80ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::hitsTheFloor2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hitsTheFloor2 verifie si l'objet est enfonce en bas de la scene. </p>
<dl class="section return"><dt>Renvoie</dt><dd>true si une partie de l'<a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> courant depasse le bas de la scene </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00111">111</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_a08a364d539d87eb3962a15ff58c80ac2_icgraph.png" border="0" usemap="#class_scene_object_a08a364d539d87eb3962a15ff58c80ac2_icgraph" alt=""/></div>
<map name="class_scene_object_a08a364d539d87eb3962a15ff58c80ac2_icgraph" id="class_scene_object_a08a364d539d87eb3962a15ff58c80ac2_icgraph">
<area shape="rect" id="node2" href="class_scene.html#a5fecb70ddb90dcde0eb0bc66875b88ed" title="doPhysics: gere la physique (gravite+ suppressions de lignes multiples...etc)" alt="" coords="239,31,367,57"/><area shape="rect" id="node6" href="class_scene.html#ac5739680655eda8de8eb5f7dc80562fd" title="Scene::timerEvent" alt="" coords="239,81,367,108"/><area shape="rect" id="node7" href="class_scene.html#a53ff5a09e1c2b039706023677708951c" title="makeMove: fait bouger le tetromino courant suivant la commande utilisateur (a droite, a gauche ou vers le bas). L&#39;action ne sera pas effectuee si elle n&#39;est pas valide." alt="" coords="238,132,367,159"/><area shape="rect" id="node3" href="classgame_manager.html#a029638f6842dc0372ed41df0f6cc7c9c" title="mainloop : gerer les fontions ci&#45;dessous 1) verifier si on a besoin un nouveau tetrimino par la valeu..." alt="" coords="432,31,600,57"/><area shape="rect" id="node4" href="classgame_manager.html#a02a1a2ce80a6c1261744544229abb5d5" title="timerEvent va gerer les &quot;timer event&quot;" alt="" coords="664,5,837,32"/><area shape="rect" id="node5" href="class_main_window.html#a5edcbc314e782645cdf4db101eeb247d" title="quand le jeu viens de commencer, la fonction start va initiliser l&#39;affichage de niveau et de note Il ..." alt="" coords="685,56,816,83"/><area shape="rect" id="node8" href="classgame_manager.html#a0f980e9de05bc58ac618eb2f10b6232d" title="gestion des controles de clavier" alt="" coords="417,132,615,159"/><area shape="rect" id="node9" href="classwidget.html#a9bd43921188521397bfd559e878fe0af" title="quand le timer et gameManager marche, keyPressEvent() va passer les evenements au GameManager sinon i..." alt="" coords="673,132,828,159"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a47c0ac4c0c404b812b3b8d91a490e8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::hitsTheWall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hitsTheWall </p>
<dl class="section return"><dt>Renvoie</dt><dd>true si une partie de l'<a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> courant depasse la scene de l'un des deux cotes. </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00133">133</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_a47c0ac4c0c404b812b3b8d91a490e8c6_icgraph.png" border="0" usemap="#class_scene_object_a47c0ac4c0c404b812b3b8d91a490e8c6_icgraph" alt=""/></div>
<map name="class_scene_object_a47c0ac4c0c404b812b3b8d91a490e8c6_icgraph" id="class_scene_object_a47c0ac4c0c404b812b3b8d91a490e8c6_icgraph">
<area shape="rect" id="node2" href="class_scene.html#a53ff5a09e1c2b039706023677708951c" title="makeMove: fait bouger le tetromino courant suivant la commande utilisateur (a droite, a gauche ou vers le bas). L&#39;action ne sera pas effectuee si elle n&#39;est pas valide." alt="" coords="227,5,357,32"/><area shape="rect" id="node3" href="classgame_manager.html#a0f980e9de05bc58ac618eb2f10b6232d" title="gestion des controles de clavier" alt="" coords="406,5,605,32"/><area shape="rect" id="node4" href="classwidget.html#a9bd43921188521397bfd559e878fe0af" title="quand le timer et gameManager marche, keyPressEvent() va passer les evenements au GameManager sinon i..." alt="" coords="653,5,808,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4286d4f4699ef94dddebed6d149e2970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::isAdjascent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>isAdjascent verifie si les deux <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> sont adjascents, c'est a dire si l'un deux possede une partie qui est directement a droite de l'autre(ou a sa gauche...). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj,:</td><td>l'autre <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> a comparer avec le SceneObjet courant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>true si Obj et l'objet courant sont adjascents </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00164">164</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30b888761430b2a22627db6ed7313c79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::isUnder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>isUnder verifie si l'objet courant possede une partie qui est directement en dessus de Obj. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj,:</td><td>l'autre <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> a comparer avec le SceneObjet courant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>retourn true si l'objet courant possede une partie qui est directement en dessus de Obj </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00186">186</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a103908e9871f10796a6cd47c34607606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operateur de comparaison &lt;. </p>
<p>Par definition(le fonctionnement intrinseque de la classe Scene qui stock les SceneObject), les SceneObjects qu'on manipule sont disjoints. On peut alors creer une relation d'ordre en comparant les cubes elementaires les plus grands de Obj et de l'objet courant.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>true si Obj est plus petit le l'objet courant </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00072">72</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1c4b963db519ceb4c654b8616fbe03d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SceneObject::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operateur de comparaison ==. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj,:</td><td>un autre <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> a comparer avec l'objet courant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>true si Obj est egale a l'object courante (point par point) sans prendre en consideration des couleurs </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00057">57</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90ed5025e4dd72be01c4c3d438d47cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SceneObject::print </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print: affiche le contenu du <a class="el" href="class_scene_object.html" title="The SceneObject class.">SceneObject</a> courant sur le tableau passe en parametre </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>tableau de taille [Size_x][Size_y] </td></tr>
  </table>
  </dd>
</dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00223">223</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_a90ed5025e4dd72be01c4c3d438d47cbd_icgraph.png" border="0" usemap="#class_scene_object_a90ed5025e4dd72be01c4c3d438d47cbd_icgraph" alt=""/></div>
<map name="class_scene_object_a90ed5025e4dd72be01c4c3d438d47cbd_icgraph" id="class_scene_object_a90ed5025e4dd72be01c4c3d438d47cbd_icgraph">
<area shape="rect" id="node2" href="class_scene.html#a12b68950547af161d6f3f88dd00f6e53" title="show: affichage de la carte" alt="" coords="185,31,282,57"/><area shape="rect" id="node3" href="classgame_manager.html#a09fc4c141e4009bbdf79c47dc624f5f7" title="affichage Appeler S.show() regulierement pour quelle ait une copie plus recente de son etat lorsqu&#39;on..." alt="" coords="331,5,493,32"/><area shape="rect" id="node5" href="classgame_manager.html#ac69b353e652fb485c14af06213b5b955" title="show: sert d&#39;intermediaire entre la classe Scene et le widget d&#39;affichage" alt="" coords="340,56,484,83"/><area shape="rect" id="node4" href="classgame_manager.html#a02a1a2ce80a6c1261744544229abb5d5" title="timerEvent va gerer les &quot;timer event&quot;" alt="" coords="541,5,715,32"/><area shape="rect" id="node6" href="classwidget.html#a8dc7a01fc2d233cd5e9bde7ba975311a" title="timerEvent gere l&#39;affichage des pixels dans la scene" alt="" coords="564,56,692,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa84c13efa3bb490ca9443798710109c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_scene_object.html">SceneObject</a> SceneObject::simple_fall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simple_fall: fait tomber l'objet courant d'une ligne </p>
<dl class="section return"><dt>Renvoie</dt><dd>la copie de l'objet courant translate vers le bas. </dd></dl>

<p>Définition à la ligne <a class="el" href="_scene_object_8cpp_source.html#l00215">215</a> du fichier <a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a>.</p>

<p><div class="dynheader">
Voici le graphe des appelants de cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_scene_object_aa84c13efa3bb490ca9443798710109c0_icgraph.png" border="0" usemap="#class_scene_object_aa84c13efa3bb490ca9443798710109c0_icgraph" alt=""/></div>
<map name="class_scene_object_aa84c13efa3bb490ca9443798710109c0_icgraph" id="class_scene_object_aa84c13efa3bb490ca9443798710109c0_icgraph">
<area shape="rect" id="node2" href="class_scene.html#a09fef31f4f25e5c1ab2a1b4366710c05" title="gravity: fait tomber tout les objets(tout le monde tombe a la meme vitesse) et les relie entre eux (a..." alt="" coords="221,56,325,83"/><area shape="rect" id="node3" href="class_scene.html#a5fecb70ddb90dcde0eb0bc66875b88ed" title="doPhysics: gere la physique (gravite+ suppressions de lignes multiples...etc)" alt="" coords="373,31,501,57"/><area shape="rect" id="node7" href="class_scene.html#ac5739680655eda8de8eb5f7dc80562fd" title="Scene::timerEvent" alt="" coords="373,81,501,108"/><area shape="rect" id="node4" href="classgame_manager.html#a029638f6842dc0372ed41df0f6cc7c9c" title="mainloop : gerer les fontions ci&#45;dessous 1) verifier si on a besoin un nouveau tetrimino par la valeu..." alt="" coords="549,31,717,57"/><area shape="rect" id="node5" href="classgame_manager.html#a02a1a2ce80a6c1261744544229abb5d5" title="timerEvent va gerer les &quot;timer event&quot;" alt="" coords="765,5,939,32"/><area shape="rect" id="node6" href="class_main_window.html#a5edcbc314e782645cdf4db101eeb247d" title="quand le jeu viens de commencer, la fonction start va initiliser l&#39;affichage de niveau et de note Il ..." alt="" coords="787,56,917,83"/></map>
</div>
</p>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir des fichiers suivants :<ul>
<li>Source/QTetrisCore/<a class="el" href="_scene_object_8h_source.html">SceneObject.h</a></li>
<li>Source/QTetrisCore/<a class="el" href="_scene_object_8cpp_source.html">SceneObject.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré le Lundi Mars 18 2013 21:56:41 pour QTetris par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
